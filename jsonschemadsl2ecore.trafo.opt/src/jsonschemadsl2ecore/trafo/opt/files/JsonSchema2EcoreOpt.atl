-- @atlcompiler emftvm
-- @nsURI JSchemaMM=http://at.jku.bise/jsonMetaschemaMM
-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI JsonGrammarMM=http://at.jku.bise/jsongrammar/1.0
-- @nsURI CompleteOclMM=http://www.eclipse.org/ocl/2015/CompleteOCLCS


module JsonSchema2EcoreOpt;
create ecoreM : Ecore, jsonGrammar : JsonGrammarMM, oclM : CompleteOclMM from jschema : JSchemaMM;


uses JsonSchema2EcoreOptUtils;

helper def: rootEPackage : Ecore!EPackage = OclUndefined;
helper def: jsonDocumentStarter:String='jsonDocumentStarter';
helper def: packageName : String = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().lastSegment();
helper def: nsURI : String = 'http://jku.bise.at/' + thisModule.packageName;

helper def: oclFileName:String  =thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().path().concat('-opt');


rule JsonSchemaToEPackage {
	from
		jsonSchema : JSchemaMM!JsonSchema
	to 
		ePackage : Ecore!EPackage (
--			name <- jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			name <- thisModule.packageName,
--			nsPrefix <- jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			nsPrefix <- thisModule.packageName,
--			nsURI <- 'http://jku.bise.at/' + jsonSchema.eResource().getURI().trimFileExtension().lastSegment()
			nsURI <- thisModule.nsURI
		),
		jsonGrammar : JsonGrammarMM!JsonGrammar (
--			nsURI <- 'http://jku.bise.at/' + jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			nsURI <- thisModule.nsURI,
			detailedGrammar <- detailedGrammar
		), 
		detailedGrammar : JsonGrammarMM!DetailedGrammar (),

		---------- OCL initialization -------------
		completeOCL: CompleteOclMM!CompleteOCLDocumentCS(
			ownedImports <- Sequence{importCS},
			ownedPackages <- Sequence{packageDeclarationCS}
		),
		importCS : CompleteOclMM!ImportCS(
			ownedPathName <- pathNameCS
		),
		pathNameCS : CompleteOclMM!PathNameCS(
			ownedPathElements <- Sequence{pathElementWithURICS}
		),
		pathElementWithURICS : CompleteOclMM!PathElementWithURICS(
			uri <- 'http://jku.bise.at/' + jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			referredElement <- importedPackage,
			owningPathName <-pathNameCS
		),
		importedPackage :	CompleteOclMM!Package(
			name <- jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			URI <- 'http://jku.bise.at/' + jsonSchema.eResource().getURI().trimFileExtension().lastSegment()--,
		),
		packageDeclarationCS : CompleteOclMM!PackageDeclarationCS(
			ownedPathName<-packageDeclarationCSPathNameCS
		),
		packageDeclarationCSPathNameCS : CompleteOclMM!PathNameCS(
			ownedPathElements <- Sequence{packageDeclarationCSPathElementCS}
		),
		packageDeclarationCSPathElementCS : CompleteOclMM!PathElementCS(
			referredElement <- importedPackage,
			owningPathName <-packageDeclarationCSPathNameCS
		)
	do {
		---------- Create ocl file -----
		thisModule.createOclFile();
	}
}

helper def : createOclFile() : OclAny=
	"#native"!"at::jku::bise::oclgenerator::OclGenerator".refInvokeStaticOperation('createOcl',Sequence{thisModule.oclFileName, thisModule.nsURI, thisModule.packageName});


rule mapRootOrDefinitionsObjectSchemaToEClass{
	from objectSchema :JSchemaMM!ObjectSchema (objectSchema.isRootOrDefinitionOrSchemaObjectAdditionalProperties())
	to 
		eClass : Ecore!EClass (
			name<- objectSchema.buildEClassname(),
			eStructuralFeatures <-objectSchema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition))
		)
} 

abstract rule mapInPropertiesSchemaToEClass{
	from schema :JSchemaMM!Schema (schema.isKeySchemaPairInProperties()) ----- TODO add the condition that is not BooleanSchema.value=false
	using {
		propertiesEClassName : String = schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildEClassname().concat('Properties');
	}
	to 
		eClass : Ecore!EClass (
			name<- schema.buildEClassname(),
			eSuperTypes <-  Sequence{thisModule.createPropertiesEClass(propertiesEClassName)}
		)
}

rule mapInPropertiesObjectSchemaToEClass extends mapInPropertiesSchemaToEClass{
	from schema :JSchemaMM!Schema (schema.isKeySchemaPairInProperties() and schema.oclIsTypeOf(JSchemaMM!ObjectSchema))
	using {
		refSchemaDefinitonSequence : Sequence(JSchemaMM!RefSchemaDefinition) =schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!RefSchemaDefinition));
		typeSchemaDefinitionSequence : Sequence(JSchemaMM!TypeSchemaDefinition) = schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition));
	}
	to 
		eClass : Ecore!EClass (
--			eStructuralFeatures <- 	let refSchemaDefinitonSequence : Sequence(JSchemaMM!RefSchemaDefinition) = schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!RefSchemaDefinition)) in
--									if not refSchemaDefinitonSequence.isEmpty() then refSchemaDefinitonSequence
--									else schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition)) 
--									endif
						eStructuralFeatures <- 	if not refSchemaDefinitonSequence.isEmpty() then refSchemaDefinitonSequence
												else typeSchemaDefinitionSequence  endif
		)
	do {
--		if (refSchemaDefinitonSequence.isEmpty() and typeSchemaDefinitionSequence.first().findSimpleType() = #"\"object\"") 
--			 thisModule.keywords <- thisModule.keywords->union(eClass.eStructuralFeatures) ;
		 thisModule.keywords <- thisModule.keywords->union(eClass.eStructuralFeatures) ;
	}
}

rule mapInPropertiesBooleanSchemaToEClass extends mapInPropertiesSchemaToEClass{
	from schema :JSchemaMM!Schema  (schema.isKeySchemaPairInProperties() and schema.oclIsTypeOf(JSchemaMM!BooleanSchema) and schema.value=true)
--	using {
--		propertiesEClassName : String = schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildEClassname().concat('Properties');
--	}
	to 
		eClass : Ecore!EClass (
--			name<- schema.buildEClassname(),
			eStructuralFeatures <- Sequence{properties}--,
--			eSuperTypes <-  Set{thisModule.createPropertiesEClass(propertiesEClassName)}
		),
		properties:Ecore!EReference ( 
			name <- schema.getKey(),
			eType <- JSchemaMM!JsonDocument,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1
			
		)
	do {
		 thisModule.keywords <- thisModule.keywords->union(eClass.eStructuralFeatures) ;
	}	
}

abstract rule mapSchemaInPatternPropertiesEClass {
	from schema :JSchemaMM!Schema (schema.isKeySchemaPairInPatternProperties())
	using {
		propertiesEClassName : String = schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildEClassname().concat('Properties');
	} 
	to 
		eClass : Ecore!EClass (
			name<- schema.buildEClassname(),
			eSuperTypes <-  Set{thisModule.createPropertiesEClass(propertiesEClassName)}
		),
		key : Ecore!EAttribute(
			name<-'key',
			lowerBound <-1,
			upperBound <- 1,
			eType <- Ecore!EString
		)
	do {
			thisModule.keyValues <- thisModule.keyValues->union(Sequence{key});
	}	
}

rule mapObjectSchemaInPatternPropertiesEClass extends mapSchemaInPatternPropertiesEClass{
	from schema :JSchemaMM!Schema (schema.isKeySchemaPairInPatternProperties() and schema.oclIsTypeOf(JSchemaMM!ObjectSchema))
--	using {
--		patternPropertiesType : JSchemaMM!TypeSchemaDefinition = schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition));
--	} 
	to 
		eClass : Ecore!EClass (
--			eStructuralFeatures <- Set{key,patternPropertiesType}.flatten() 
			eStructuralFeatures <- Set{key,let refSchemaDefinitonSequence : Sequence(JSchemaMM!RefSchemaDefinition) = schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!RefSchemaDefinition)) in
										if not refSchemaDefinitonSequence.isEmpty() then refSchemaDefinitonSequence
										else schema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition)) 
										endif
									}.flatten() 
		),
		key : Ecore!EAttribute 
}

rule mapBooleanSchemaInPatternPropertiesEClass extends mapSchemaInPatternPropertiesEClass{
--	from booleanSchema :JSchemaMM!BooleanSchema (
--		booleanSchema.isKeySchemaPairInPatternProperties()
--		and booleanSchema.value=true
--	)
	from schema :JSchemaMM!Schema  (
		schema.isKeySchemaPairInPatternProperties()
		and schema.oclIsTypeOf(JSchemaMM!BooleanSchema)
		and schema.value=true
	)
	using {
--		propertiesEClassName : String = booleanSchema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildEClassname().concat('Properties');
	} 
	to 
		eClass : Ecore!EClass (
--			name<- booleanSchema.buildEClassname(),
			eStructuralFeatures <- Set{key,patternProperties}--,
--			eSuperTypes <-  Set{thisModule.createPropertiesEClass(propertiesEClassName)}
		),
		key : Ecore!EAttribute,--(
--			name<-'key',
--			lowerBound <-1,
--			upperBound <- 1,
--			eType <- Ecore!EString
--		),
		patternProperties:Ecore!EReference ( 
--			name <- booleanSchema.getKey(),
			name <- schema.getKey(),
			eType <- JSchemaMM!JsonDocument,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1
			
		)
}

abstract rule mapAdditionalPropertiesEClass {
	from additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalPropertiesSchemaDefinition
	using {
		additionalPropertiesName : String = additionalPropertiesSchemaDefinition.additionalProperties.buildEClassname();
		propertiesEClassName : String = 	additionalPropertiesSchemaDefinition.refImmediateComposite().buildEClassname().concat('Properties');
	}
	to
		eClass : Ecore!EClass (
		 	name <-	additionalPropertiesName,
			eSuperTypes <-  Set{thisModule.createPropertiesEClass(propertiesEClassName)}
		),
		
		key : Ecore!EAttribute(
			name<-'key',
			lowerBound <-1,
			upperBound <- 1,
			eType <- Ecore!EString
		)
		do {
			thisModule.keyValues <- thisModule.keyValues->union(Sequence{key});
		}
}

rule mapObjectSchemaAdditionalPropertiesEClass extends mapAdditionalPropertiesEClass{
	from additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalPropertiesSchemaDefinition (additionalPropertiesSchemaDefinition.additionalProperties.oclIsTypeOf(JSchemaMM!ObjectSchema))
	using {
--		additionalPropertiesType : JSchemaMM!TypeSchemaDefinition = additionalPropertiesSchemaDefinition.additionalProperties.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition));
		additionalPropertiesObjectSchema : JSchemaMM!ObjectSchema = additionalPropertiesSchemaDefinition.additionalProperties;
	}
	to
		eClass : Ecore!EClass (
--			eStructuralFeatures <- Set{key, additionalPropertiesType}.flatten()
			eStructuralFeatures <- Sequence{key,let refSchemaDefinitonSequence : Sequence(JSchemaMM!RefSchemaDefinition) = additionalPropertiesObjectSchema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!RefSchemaDefinition)) in
										if not refSchemaDefinitonSequence.isEmpty() then refSchemaDefinitonSequence
										else additionalPropertiesObjectSchema.keywordDefinition->select(keyword  | keyword.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition)) 
										endif
									}.flatten() 
									
									
		),
		key : Ecore!EAttribute		
}

rule mapBooleanSchemaAdditionalPropertiesEClass extends mapAdditionalPropertiesEClass{
	from additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalPropertiesSchemaDefinition (
		additionalPropertiesSchemaDefinition.additionalProperties.oclIsTypeOf(JSchemaMM!BooleanSchema) and 
		additionalPropertiesSchemaDefinition.additionalProperties.value=true
	)
	using {
--		additionalPropertiesName : String = additionalPropertiesSchemaDefinition.additionalProperties.buildEClassname();
--		
--		propertiesEClassName : String = 	additionalPropertiesSchemaDefinition.refImmediateComposite().buildEClassname().concat('Properties');
	}
	to
		eClass : Ecore!EClass (
--		 	name <-	additionalPropertiesName,
			eStructuralFeatures <- Set{key, additionalProperties}.flatten()
--			eSuperTypes <-  Set{thisModule.createPropertiesEClass(propertiesEClassName)}
		),
		key : Ecore!EAttribute,
--		key : Ecore!EAttribute(
--			name<-'key',
--			lowerBound <-1,
--			upperBound <- 1,
--			eType <- Ecore!EString
--		),
		additionalProperties: Ecore!EReference(
			name<-'additionalProperties',
			containment <- true,
			lowerBound <-1,
			upperBound <- 1,
			eType <- JSchemaMM!JsonDocument
		)
}

rule mapDefaultAdditionalPropertiesEClass  extends createPropertiesContainmentAndMapDefaultAdditionalPropertiesEClass{
	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (
		typeSchemaDefinition.findSimpleType() = #"\"object\"" and
		typeSchemaDefinition.refImmediateComposite().keywordDefinition->exists(keyword  | keyword.oclIsTypeOf(JSchemaMM!AdditionalPropertiesSchemaDefinition)) = false
	)
	using {
		additionalPropertiesName : String = typeSchemaDefinition.refImmediateComposite().buildEClassname().concat('AdditionalProperties');
		propertiesEClassName : String = 	typeSchemaDefinition.refImmediateComposite().buildEClassname().concat('Properties');
	}
	to
		eReference :Ecore!EReference,
		eClass : Ecore!EClass (
		 	name <-	additionalPropertiesName,
			eStructuralFeatures <- Set{key, additionalProperties}.flatten(),
			eSuperTypes <-  Set{thisModule.createPropertiesEClass(propertiesEClassName)}
		),
		key : Ecore!EAttribute(
			name<-'key',
			lowerBound <-1,
			upperBound <- 1,
			eType <- Ecore!EString
		),
		additionalProperties: Ecore!EReference(
			name<-'additionalProperties',
			containment <- true,
			lowerBound <-1,
			upperBound <- 1,
			eType <- JSchemaMM!JsonDocument
		)
}



abstract rule createPropertiesContainmentAndMapDefaultAdditionalPropertiesEClass{
	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (typeSchemaDefinition.findSimpleType() = #"\"object\"")	
	to 
		eReference :Ecore!EReference ( 
			name <- 'properties',
			eType <- thisModule.createPropertiesEClass(typeSchemaDefinition.refImmediateComposite().buildEClassname().concat('Properties')),
--			eType <- thisModule.createPropertiesEClass(typeSchemaDefinition),
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
			
		)
	do {
		thisModule.curlyBracesEReferences <- thisModule.curlyBracesEReferences->union(Sequence{eReference}); 
	}	
}

rule createPropertiesContainment extends createPropertiesContainmentAndMapDefaultAdditionalPropertiesEClass{
	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (
		typeSchemaDefinition.findSimpleType() = #"\"object\"" 
		and	typeSchemaDefinition.refImmediateComposite().keywordDefinition->exists(keyword  | keyword.oclIsTypeOf(JSchemaMM!AdditionalPropertiesSchemaDefinition)) = true
		
	)	
	to 
		eReference :Ecore!EReference 

		do {
			-- we put curly braces to the enclosing object schema
--			thisModule.curlyBracesEReferences <- thisModule.curlyBracesEReferences->union(Sequence{eReference}); 
--			thisModule.curlyBracesEClass <- thisModule.curlyBracesEClass->union(Sequence{eReference.refImmediateComposite()}); 
		}
}


abstract rule mapItemsSchemaToEClass{
	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (typeSchemaDefinition.findSimpleType() = #"\"array\"")
	to
		eClass:  Ecore!EClass (
			name <- typeSchemaDefinition.refImmediateComposite().buildEClassname().concat('Items')
		),
		eReference :Ecore!EReference ( 
--			name <- 'items',
			name <- typeSchemaDefinition.refImmediateComposite().getKey(),
			eType <- eClass,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
			
		)
		do{
			thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
			thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
		}
}

rule mapItemsObjectSchemaToEClass extends mapItemsSchemaToEClass{
	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (
		typeSchemaDefinition.findSimpleType() = #"\"array\""
		and (
			let itemsKeywordDefinitionSequence : Sequence(JSchemaMM!ItemsSchemaDefinition) = typeSchemaDefinition.refImmediateComposite().keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!ItemsSchemaDefinition)) in  
			not itemsKeywordDefinitionSequence.isEmpty() and itemsKeywordDefinitionSequence.first().itemsAnyOf1.oclIsTypeOf(JSchemaMM!ObjectSchema)
		)
	)	
	using {
		itemsKeywordDefinitionSequence : Sequence(JSchemaMM!KeywordDefinition) = typeSchemaDefinition.refImmediateComposite().keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!ItemsSchemaDefinition)).first().itemsAnyOf1.keywordDefinition;
	}
	to 
		eReference :Ecore!EReference,
		eClass:  Ecore!EClass (
--			eStructuralFeatures <- Sequence{typeSchemaDefinition.refImmediateComposite().keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!ItemsSchemaDefinition)).first().itemsAnyOf1.keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition))}.flatten() 
			eStructuralFeatures <- 	Sequence{let refSchemaDefinitonSequence : Sequence(JSchemaMM!RefSchemaDefinition) = itemsKeywordDefinitionSequence->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!RefSchemaDefinition)) in 
										if not refSchemaDefinitonSequence.isEmpty() then refSchemaDefinitonSequence
										else itemsKeywordDefinitionSequence->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition))
										endif	
									}.flatten() 
		)
--	do {
--		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
----		thisModule.bracketsEClass <- thisModule.bracketsEClass->union(Sequence{eReference.refImmediateComposite()});
--	}
}



rule mapItemsBooleanSchemaOrDefaultToEClass extends mapItemsSchemaToEClass{
	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (
		typeSchemaDefinition.findSimpleType() = #"\"array\""
		and (
			let itemsKeywordDefinition : Sequence(JSchemaMM!ItemsSchemaDefinition) = typeSchemaDefinition.refImmediateComposite().keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!ItemsSchemaDefinition)) in  
			itemsKeywordDefinition.isEmpty() ---- true is the Default case
			or(itemsKeywordDefinition.first().itemsAnyOf1.oclIsTypeOf(JSchemaMM!BooleanSchema) and itemsKeywordDefinition.first().itemsAnyOf1.value=true )
		)	
	)	
	to 
		eReference :Ecore!EReference,
		eClass:  Ecore!EClass (
			eStructuralFeatures <- Sequence{itemsEReference}
		),
		itemsEReference:Ecore!EReference (
			name <- 'items',
			eType <- JSchemaMM!JsonSchema,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1
		)	
}


rule mapRefSchemaToEReference{
	from refSchemaDefinition: JSchemaMM!RefSchemaDefinition 
	using {
		referenceType : String = thisModule.retrieveRootSchema().findSchemaByJsonPointerFromRoot(refSchemaDefinition.ref)
									.keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition))
								.first().findSimpleType();
	} to		
		eReference :Ecore!EReference ( 
			name <- refSchemaDefinition.refImmediateComposite().getKey(),
			eType <- thisModule.retrieveRootSchema().findSchemaByJsonPointerFromRoot(refSchemaDefinition.ref),
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1			
		)
	do {
		if (referenceType = #"\"object\"" ) {
--			thisModule.curlyBracesEReferences <- thisModule.curlyBracesEReferences->union(Sequence{eReference});
--			thisModule.curlyBracesEClass <- thisModule.curlyBracesEClass->union(Sequence{eReference.refImmediateComposite()});
		} else if (referenceType = #"\"array\"" ) {
			thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
--			thisModule.bracketsEClass <- thisModule.bracketsEClass->union(Sequence{eReference.refImmediateComposite()});
		} 
	}	
}


rule createEAttributeSimpleScalar{
	from 
		typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (not typeSchemaDefinition.getEDataType().oclIsUndefined())	
	to 
		eAttribute : Ecore!EAttribute(
			name<-typeSchemaDefinition.refImmediateComposite().getKey(),
			lowerBound <-1,
			upperBound <- 1,
			eType <- typeSchemaDefinition.getEDataType()
		)
	do {
--		if (typeSchemaDefinition.refImmediateComposite().refImmediateComposite().oclIsTypeOf(JSchemaMM!KeySchemaPair)
--				and not typeSchemaDefinition.refImmediateComposite().oclIsTypeOf(JSchemaMM!ItemsSchemaDefinition)) 		
--			thisModule.keywords <- thisModule.keywords->union(Sequence{eAttribute});
	}
}

unique lazy rule createPropertiesEClass{
	from name:String
--	from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition
--	using {
--		name : String =  typeSchemaDefinition->debug('ddddddddddddddddddd').refImmediateComposite().buildEClassname().concat('Properties');
--	}
	to
		eClass : Ecore!EClass (
			name <- name.concat('Abstract'),
			abstract<- true
		)	
}

-------------------- OCL Generation --------------------------------

rule minimumConstraintToOCLJava {
	from minimumSchemaDefinition : JSchemaMM!MinimumSchemaDefinition
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = minimumSchemaDefinition.refImmediateComposite();
	}
	do {
--	 	thisModule.appendMinimumConstraint(enclosingSchema.buildEClassname(), minimumSchemaDefinition.minimum);
		thisModule.appendMinimumConstraint(thisModule.packageName+'::'+enclosingSchema.buildEClassname(), enclosingSchema.buildEClassname()+'Minimum', minimumSchemaDefinition.minimum);
	}
}

helper def : appendMinimumConstraint(contextClass: String, inv:String, minimum: Real ) : OclAny=
--	"#native"!"at::jku::bise::oclgenerator::OclGenerator".refInvokeStaticOperation('appendMinimumConstraint',Sequence{thisModule.packageName, contextClass, minimum});
	"#native"!"at::jku::bise::oclgenerator::OclGenerator".refInvokeStaticOperation('appendMinimumConstraint',Sequence{thisModule.oclFileName, contextClass, inv, minimum});

rule requiredInProperties{
	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
		required : Sequence(String) = requiredSchemaDefinition.required.values->debug('requireds');
		
		inPropertiesRequiredKeySchemaPairs : Sequence(JSchemaMM!KeySchemaPair)= 
			let propertiesSchemaDefinitions : Sequence(JSchemaMM!PropertiesSchemaDefinition) = 
				enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PropertiesSchemaDefinition))
			in
				if propertiesSchemaDefinitions->debug('propertiesSchemaDefinitions').isEmpty() then Sequence{}
				else
					propertiesSchemaDefinitions->first().keySchemaPairs->select(ksp| required->debug('required2')->includes(ksp.key.stripFirstAndLast()->debug('ksp.key')))
				endif;
				
	
		inPropertiesRequiredSchemas : Sequence(JSchemaMM!Schema)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.value);	
		inPropertiesRequiredKeys : Sequence(String)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.key);	
		requiredNotInProperties:Sequence(String) = required->excludingAll(inPropertiesRequiredKeys);
	}
	do{
		for (p in inPropertiesRequiredKeySchemaPairs) {
--			thisModule.appendRequiredInPropertiesConstraint(enclosingSchema.buildEClassname(), p.key.stripFirstAndLast(), p.value.buildEClassname());
			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName+'::'+enclosingSchema.buildEClassname(), enclosingSchema.buildEClassname()+'Required', p.key.stripFirstAndLast(), p.value.buildEClassname());
		}
		
--		inPropertiesRequiredKeySchemaPairs->debug('inPropertiesRequiredKeySchemaPairs')->collect(p | thisModule.appendRequiredInPropertiesConstraint(enclosingSchema.buildEClassname(), p.key, p.value.buildEClassname()));
	}
}

helper def : appendRequiredInPropertiesConstraint(contextClass: String, inv:String, requiredProperty: String,   requiredClassType : String) : OclAny=
	"#native"!"at::jku::bise::oclgenerator::OclGenerator".refInvokeStaticOperation('appendRequiredInPropertiesConstraint',Sequence{thisModule.oclFileName, contextClass, inv, requiredProperty, requiredClassType});



--helper def: allPackageDeclarationCS() : Sequence(CompleteOclMM!PackageDeclarationCS) = CompleteOclMM!PackageDeclarationCS.allInstancesFrom('oclM');
--helper def: shipyardContextDeclCSSequence : Sequence(CompleteOclMM!ContextDeclCS) = Sequence{};

--rule requiredConstraintToOCL{
--	--------- TODO this rule only check if the required values are present under "properties" -------------------------------------------------------------------
--	--------- TODO. Modify the rule to search in "additionalProperties" (even when it is present by default and not explicltly) and in "patternProperties" ------
--	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition
--	using {
--		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
--		required : Sequence(String) = requiredSchemaDefinition.required.values;
--		
--		inPropertiesRequiredKeySchemaPairs : Sequence(JSchemaMM!KeySchemaPair)= 
--			let propertiesSchemaDefinitions : Sequence(JSchemaMM!PropertiesSchemaDefinition) = 
--				enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PropertiesSchemaDefinition))
--			in
--				if propertiesSchemaDefinitions.isEmpty() then Sequence{}
--				else
--					propertiesSchemaDefinitions->first().keySchemaPairs->select(ksp| required->includes(ksp.key))
--				endif;
--				
--	
--		inPropertiesRequiredSchemas : Sequence(JSchemaMM!Schema)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.value);	
--		inPropertiesRequiredKeys : Sequence(String)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.key);	
--		requiredNotInProperties:Sequence(String) = required->excludingAll(inPropertiesRequiredKeys);
--	}
--	to
--		classifierContextDeclCS: CompleteOclMM!ClassifierContextDeclCS (
--			ownedPathName <- pathNameCS,
--			ownedInvariants <- Sequence{constraintCS} 
--		),pathNameCS: CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{pathElementCS} 
--		),
--		pathElementCS : CompleteOclMM!PathElementCS(
--			referredElement <- contextClass,
--			owningPathName <-pathNameCS
--		),
--		contextClass : CompleteOclMM!Class(
--			name <- enclosingSchema.buildEClassname()
--		),
--		constraintCS : CompleteOclMM!ConstraintCS(
--			name <- enclosingSchema.buildEClassname().concat('Required'),
--			ownedSpecification <-expSpecificationCS,
--			ownedMessageSpecification <- ownedMessageSpecificationCS
--		),
--		ownedMessageSpecificationCS : CompleteOclMM!ExpSpecificationCS(
--			ownedExpression <-stringLiteralExpCS
--		),
--		stringLiteralExpCS :CompleteOclMM!StringLiteralExpCS(
--			segments<-Sequence{'For the object '.concat(enclosingSchema.buildEClassname().concat('the properties ').concat(requiredNotInProperties.toString().concat('are required, but they are missing')))} 
--			
--		),
--		expSpecificationCS : CompleteOclMM!ExpSpecificationCS(
--			ownedExpression <- ifExpCS
--		),
--		ifExpCS :CompleteOclMM!IfExpCS(
--			ownedCondition <- infixExpCS,
--			ownedThenExpression <- booleanLiteralExpCS,
--			ownedElseExpression <- nullLiteralExpCS
--		),
--		------ properties->select
--		infixExpCS :CompleteOclMM!InfixExpCS( 
--			name <- '->',
--			pivot <- propertiesSelectIteratorExp, -------- TODO is this necessary?
--			ownedLeft<-selOwnedLeft,
--			ownedRight<-selOwnedRight
--		),
--		propertiesSelectIteratorExp:CompleteOclMM!IteratorExp( -------- TODO is this necessary?
--			name<-'select'
--		),
--		selOwnedLeft:CompleteOclMM!NameExpCS(
--			ownedPathName <- selLeftPathName
--		),
--		selLeftPathName:CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{selLeftPathElementCS}
--			
--		),
--		selLeftPathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- selLeftPathName,
--			referredElement <- selLeftProperty
--		),
--		selLeftProperty :CompleteOclMM!Property(
--			name <- 'properties'
--		),
--		selOwnedRight:CompleteOclMM!InfixExpCS(
--			
--			name <- '->',
--			pivot <- propertiesCollectIteratorExp, -------- TODO is this necessary?
--			ownedLeft <- collOwnedLeft,
--			ownedRight <- collOownedRight
--		),
--		propertiesCollectIteratorExp :CompleteOclMM!IteratorExp( -------- TODO is this necessary?
--			name<- 'collect'
--		),
--		collOwnedLeft: CompleteOclMM!NameExpCS(
--			ownedPathName <- collectLeftPathNameCS,
--			ownedRoundBracketedClause <- collectLeftOwnedRoundBracketedClauseCS
--		),
--		collectLeftPathNameCS:CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{collectLeftPathElementCS}
--		),
--		collectLeftPathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- collectLeftPathNameCS,
--			referredElement <- collectLeftIteration
--		),
--		collectLeftIteration : CompleteOclMM!Iteration(
--			name<-'select'
--		),
--		collectLeftOwnedRoundBracketedClauseCS : CompleteOclMM!RoundBracketedClauseCS(
--			ownedArguments <- Sequence{collectLeftBracketedClauseNavigation1, collectLeftBracketedClauseNavigation2} 
--		),
--		collectLeftBracketedClauseNavigation1 :  CompleteOclMM!NavigatingArgCs(
--			ownedNameExpression <- Sequence{collectLeftBracketedClauseNavigation1NameExpCS} 
--		),
--		collectLeftBracketedClauseNavigation2 :  CompleteOclMM!NavigatingArgCs(
--			ownedNameExpression <- Sequence{collectLeftBracketedClauseNavigation2InfixExpCS} 
--		),
--		collectLeftBracketedClauseNavigation1NameExpCS:CompleteOclMM!NameExpCS(
--			ownedPathName <- collectLeftBracketedClauseNavigation1PathNameCS
--		),
--		
--		collectLeftBracketedClauseNavigation1PathNameCS:CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{collectLeftBracketedClauseNavigation1PathElementCS}
--		),
--		collectLeftBracketedClauseNavigation1PathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- collectLeftBracketedClauseNavigation1PathNameCS,
--			referredElement <- collectLeftBracketedClauseNavigation1IteratorVariable
--		),
--		collectLeftBracketedClauseNavigation1IteratorVariable : CompleteOclMM!IteratorVariable(
--			name <- 'p'
--		)
--		
--		-------   Sequence{....} ->includes (p.oclType())
--		collectLeftBracketedClauseNavigation2InfixExpCS : CompleteOclMM!InfixExpCS( 
--			--------- TODOOOO ------------
--			name <- '->',
----			ownedLeft<-selOwnedLeft,
--			ownedRight<-includesOwnedRight
--		),
--		
--		includesOwnedRight :  CompleteOclMM!CompleteOclMM!NameExpCS(
--			ownedPathName <- includesRigthPathNameCS,
--			ownedRoundBracketedClause <- includesRigthBracketedClause
--		)
--		includesRigthPathNameCS: CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{includesRigthPathElementCS}
--		),
--		includesRigthPathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- includesRigthPathNameCS,
--			referredElement <- includesRightOperation
--		),
--		includesRightOperation : CompleteOclMM!Operation(
--			name <- 'includes'	
--		),
--		includesRigthBracketedClause : CompleteOclMM!CompleteOclMM!RoundBracketedClauseCS(
--			----------TODO -----------------
--		)
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		
--		--------   collect(p|p.oclType())->includesAll(Sequence{.....})   ---------------
--		selectOownedRight:CompleteOclMM!InfixExpCS(
--			name <- '->',
--			pivot <- includesAllOperationCallExp, -------- TODO is this necessary?
--			ownedLeft <- includesAllOwnedLeft,
--			
--			ownedRight <- includesAllOwnedRight
--		),
--			
--		includesAllOperationCallExp : CompleteOclMM!OperationCallExp( -------- TODO is this necessary?
--			name<- 'includesAll'
--		),
--		includesAllOwnedRight :CompleteOclMM!NameExpCS(
--			------------ TODO -------
--			ownedPathName <- includesAllRigthPathNameCS,
--			ownedRoundBracketedClause <- includesAllRightOwnedRoundBracketedClauseCS
--		),
--		
--		includesAllRigthPathNameCS: CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{includesAllRightPathElementCS}
--		),
--		includesAllRigthPathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- includesAllRigthPathNameCS,
--			---  referredElement <- includesAllLeftOperation
--		),
--		
--		includesAllOwnedLeft:CompleteOclMM!NameExpCS(
--			ownedPathName <- includesAllLeftPathNameCS,
--			ownedRoundBracketedClause <- includesAllLeftOwnedRoundBracketedClauseCS
--		),
--		
--		includesAllLeftPathNameCS:CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{includesAllLeftPathElementCS}
--		),
--		includesAllLeftPathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- includesAllLeftPathNameCS,
--			referredElement <- includesAllLeftOperation
--		),
--		includesAllLeftOperation : CompleteOclMM!Operation(
--			name <- 'includesAll'
--		),
--		includesAllLeftOwnedRoundBracketedClauseCS:CompleteOclMM!RoundBracketedClauseCS(
--			ownedArguments <- Sequence{includesAllLeftNavigatingArgCs}
--		),
--		includesAllLeftNavigatingArgCs :  CompleteOclMM!NavigatingArgCs(
--			ownedNameExpression <- Sequence{includesAllLeftCollectionLiteralExpCS}
--		),
--		includesAllLeftCollectionLiteralExpCS : CompleteOclMM!CollectionLiteralExpCS(
--			ownedType : includesAllLeftCollectionTypeCS,
--			ownedParts <- inPropertiesRequiredSchemas->collect(requiredSchema | thisModule.mapSchemaToCollectionLiteralPartCS(requiredSchema))
--		),
--		includesAllLeftCollectionTypeCS :CompleteOclMM!CollectionTypeCS(
--			name<-'Sequence'
--		)
--	
--		booleanLiteralExpCS:CompleteOclMM!BooleanLiteralExpCS(
--			symbol<-'true'
--		),
--		nullLiteralExpCS:CompleteOclMM!NullLiteralExpCS(
--		)
--	do {
--		thisModule.shipyardContextDeclCSSequence <- thisModule.shipyardContextDeclCSSequence->union(Sequence{classifierContextDeclCS});
--	}
--}
--
--lazy rule mapSchemaToCollectionLiteralPartCS{
--	from schema : JSchemaMM!Schema
--	to 
--		CompleteOclMM!CollectionLiteralPartsCS(
--			ownedExpression <- nameExpCS
--		),
--		nameExpCS:CompleteOclMM!NameExpCS(
--			ownedPathName <- pathNameCS
--		),
--		pathNameCS:CompleteOclMM!PathNameCS(
--			ownedPathElements <- Sequence{pathElementCS}
--			
--		),
--		pathElementCS : CompleteOclMM!PathElementCS(
--			owningPathName <- pathNameCS,
--			referredElement <- class
--		),
--		class : CompleteOclMM!Class(
--			name <- schema.buildEClassname()
--		)
--}
---------------------------DO Not delete --------------------------------------
--rule requiredConstraintToOCL{
--	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition
--	
--	using {
--		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
--		required:Sequence(String) =requiredSchemaDefinition.required
--		inPropertiesSchemas: Sequence(JSchemaMM!Schema)= enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PropertiesSchemaDefinition)).keySchemaPairs->collect(ksp | ksp.value) 
--		additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalPropertiesSchemaDefinition = enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!AdditionalPropertiesSchemaDefinition))
--		inPatternPropertiesSchemas: Sequence(JSchemaMM!Schema)= enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition)).keySchemaPairs->collect(ksp | ksp.value) 
--		inPropertiesSchemasRequired : Sequence(JSchemaMM!Schema)= ---- schemas with keys included in required
--		requiredNotInProperties:Sequence(String)
--	}
--	to ocl(
--		context <- enclosingSchema,
--		inv <- --'self.properties->select(p|'+inPropertiesSchemas+'includes(p.oclType()) and'+ inPropertiesSchemas+')'
--			'self.properties->select(p|'+inPropertiesSchemasRequired+'includes(p.oclType())).oclAsType(Set) = '+inPropertiesSchemasRequired+'.oclAsType(Set) and'+
--		   	'self.properties->select(p|p.oclIsTypeOf('+additionalPropertiesSchemaDefinition+'))->collect(p|p.key)->union'
--		   	'(self.properties->select(p|'+inPatternPropertiesSchemas+'includes(p.oclType()))->collect(p|p.key)).oclAsType(Set)'
--		   
--		 
--	)
--}

endpoint rule CompletEPackageAndJsonGrammar() {
	do {
		thisModule.packageRoot().eClassifiers <- thisModule.allEClass();	
		---- Json Grammar
		thisModule.jsonGrammarRoot().detailedGrammar.keywords <- thisModule.keywords;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesReferences <- thisModule.curlyBracesEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsReferences <- thisModule.bracketsEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.keyValue <- thisModule.keyValues;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesEClass <- thisModule.curlyBracesEClass;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsEClass <- thisModule.bracketsEClass;
		
--		thisModule.repeatedEClassName();
		---- OCL generation--------
		thisModule.endPackage();
		
	}
}

helper  def : endPackage() : OclAny=
	"#native"!"at::jku::bise::oclgenerator::OclGenerator".refInvokeStaticOperation('endPackage',Sequence{thisModule.oclFileName});


--helper def: eclassEObjects() : Sequence(Ecore!EClass) = Ecore!EClass.allInstancesFrom('ecoreM');
--
----helper def: repeatedEClassName() : Sequence(Ecore!EClass) = 
--helper def: repeatedEClassName() : Integer = 	
--	thisModule.eclassEObjects()->debug('eclass')->iterate(eClass ; cont: Integer = 0 |
--		if thisModule.eclassEObjects()->select(eClass2|eClass2.name=eClass.name).size()->debug('size')>1 then eClass.name  = eClass.name.concat(cont.toString())
--		else OclUndefined endif
--	)	;
--		let selection : Sequence(Ecore!EClass) = thisModule.eclassEObjects().select(sameNameEClass|sameNameEClass.name=eClass.name) in
--	   	if selection.size()>0 then  selection.iterate(repeatedEClass; )
-- 	)
--	thisModule.eclassEObjects().iterate(currentEClass; map: Map(String, Sequence(Ecore!EClass)) = Map{} |
--		if map.get(currentEClass.name)  = OclUndefined then map<-map.including(currentEClass.name, Sequence{currentEClass})
--		else map.get(currentEClass.name)<-includingAll (Sequence{currentEClass})
--		endif
--	).
--    thisModule.eclassEObjects()->collect(eClass | thisModule.eclassEObjects().mappedBy(eClass2|eClass=eClass2)
--    	.forAll(map | body)
--	body

	-- let repeated : Sequence(Ecore!EClass) = Sequence{}in

--	thisModule.eclassEObjects()->iterate(iterator; repeated : Sequence(Ecore!EClass) = Sequence{} |
--	if map.get(iterator) = OclUndefined then map<-map.including(iterator, 0)
--	else 

 




